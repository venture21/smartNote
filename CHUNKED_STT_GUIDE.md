# 긴 오디오 파일 청크 처리 STT 가이드

## 개요

Gemini 2.5 Pro 모델을 사용한 STT 작업 시, 긴 녹음 파일(예: 1시간 이상)에서 JSON 파싱 에러가 자주 발생하는 문제를 해결하기 위해 **청크 처리 방식**을 구현했습니다.

이 방식은 긴 오디오를 작은 청크로 나누어 처리한 후, 중복 구간을 사용하여 텍스트를 정확하게 병합합니다.

## 🎯 웹 UI에서 사용하기 (권장)

웹 인터페이스에서 직관적으로 청크 시간을 선택할 수 있습니다!

### 1. 애플리케이션 시작
```bash
python main.py
```

브라우저에서 http://127.0.0.1:5000 접속

### 2. YouTube 영상 처리
1. **영상 검색** 탭 선택
2. YouTube URL 입력
3. **오디오 분할 시간** 드롭다운에서 선택:
   - **10분** (짧은 청크, 안정성 높음) - 매우 긴 파일이나 에러 발생 시 권장
   - **20분** (균형) - 일반적인 긴 파일에 권장
   - **30분** (긴 청크, 빠름) - 기본값, 1시간 정도 파일에 적합
4. **영상 처리 시작** 버튼 클릭

### 3. 오디오 파일 업로드
1. **오디오 검색** 탭 선택
2. 오디오 파일 업로드 (드래그 앤 드롭 또는 클릭)
3. **오디오 분할 시간** 드롭다운에서 선택
4. **오디오 처리 시작** 버튼 클릭

### 4. 진행 상황 확인
- 오디오 분할 중...
- 청크 1/3 처리 중...
- 청크 2/3 처리 중...
- 세그먼트 병합 중...
- STT 완료!

## 주요 기능

### 1. 오디오 분할 (`split_audio_with_overlap`)
- 긴 오디오 파일을 지정된 길이의 청크로 분할
- 각 청크 사이에 중복 구간(overlap) 설정
- 기본값: 30분 청크, 25초 중복

### 2. 텍스트 병합 (`merge_segment_lists`)
- 중복 구간의 텍스트를 비교하여 가장 유사한 부분 찾기
- 유사도 기반 매칭 (80% 이상 유사도)
- 중복 제거 후 세그먼트 병합

### 3. 청크 처리 STT (`recognize_with_gemini_chunked`)
- 오디오 분할 → 각 청크 STT 처리 → 결과 병합
- 실패 시 자동으로 일반 처리 방식으로 fallback
- 진행 상황 추적 지원

## 사용 방법

### 기본 사용

```python
from modules.stt import recognize_with_gemini_chunked

# 기본 설정 (30분 청크, 25초 중복)
segments, processing_time, language = recognize_with_gemini_chunked(
    audio_path="mp3/long_meeting.mp3"
)

if segments:
    print(f"처리 완료: {len(segments)}개 세그먼트")
    print(f"감지 언어: {language}")
    print(f"처리 시간: {processing_time:.2f}초")
```

### 커스텀 설정

```python
# 20분 청크, 30초 중복
segments, processing_time, language = recognize_with_gemini_chunked(
    audio_path="mp3/long_meeting.mp3",
    chunk_duration_minutes=20,
    overlap_seconds=30
)
```

### 진행 상황 추적

```python
# task_id를 전달하여 진행 상황 추적
segments, processing_time, language = recognize_with_gemini_chunked(
    audio_path="mp3/long_meeting.mp3",
    task_id="task_123"
)
```

## 테스트 스크립트

프로젝트에 포함된 `test_chunked_stt.py`를 사용하여 테스트할 수 있습니다.

### 기본 테스트

```bash
python test_chunked_stt.py mp3/long_meeting.mp3
```

### 커스텀 설정 테스트

```bash
# 20분 청크, 30초 중복
python test_chunked_stt.py mp3/long_meeting.mp3 20 30
```

## 파라미터 설명 및 권장 사항

### `chunk_duration_minutes` (기본값: 30)
각 청크의 길이 (분 단위)를 설정합니다.

#### 옵션별 특징:

**10분 청크 (안정성 최우선)**
- ✅ 장점:
  - JSON 파싱 에러 발생 가능성 최소화
  - 매우 긴 파일(2시간 이상)에 안정적
  - 에러 발생 시 재처리 부담 적음
- ⚠️ 단점:
  - 청크 수가 많아 전체 처리 시간 증가
  - 병합 과정이 복잡해질 수 있음
- 📋 권장 상황:
  - 2시간 이상의 매우 긴 파일
  - 이전에 30분 설정으로 에러 발생한 경우
  - 안정성이 속도보다 중요한 경우

**20분 청크 (균형)**
- ✅ 장점:
  - 안정성과 속도의 균형
  - 1-2시간 파일에 적합
  - 적당한 청크 수
- ⚠️ 단점:
  - 특별한 단점 없음 (중간 옵션)
- 📋 권장 상황:
  - 1-2시간 길이의 일반적인 회의/강의
  - 첫 시도 시 에러가 발생한 경우
  - 대부분의 경우에 무난한 선택

**30분 청크 (기본값, 속도 우선)**
- ✅ 장점:
  - 빠른 처리 속도
  - 청크 수 최소화
  - 1시간 이하 파일은 분할 안 됨 (자동 일반 처리)
- ⚠️ 단점:
  - 매우 긴 파일에서 JSON 에러 가능성 있음
  - 에러 발생 시 재처리 시간 손실
- 📋 권장 상황:
  - 30분-1시간 길이의 파일
  - 빠른 처리가 필요한 경우
  - 시스템 리소스가 충분한 경우

#### 파일 길이별 권장 설정:
- **30분 이하**: 자동으로 일반 처리 (분할 안 됨)
- **30분-1시간**: 30분 청크 (1-2개 청크)
- **1-2시간**: 20분 또는 30분 청크
- **2시간 이상**: 10분 또는 20분 청크 권장

### `overlap_seconds` (기본값: 25)
- 청크 간 중복 구간 (초 단위)
- 권장값: 20-30초
- 너무 짧으면: 병합 시 정확도 감소
- 너무 길면: 불필요한 중복 처리

## 작동 원리

### 1단계: 오디오 분할
```
원본 오디오 (60분)
├─ 청크 1: 0:00 ~ 30:00
├─ 청크 2: 29:35 ~ 59:35  (25초 중복)
└─ 청크 3: 59:10 ~ 60:00  (25초 중복)
```

### 2단계: 각 청크 STT 처리
```
청크 1 → 세그먼트 1-50
청크 2 → 세그먼트 51-100
청크 3 → 세그먼트 101-110
```

### 3단계: 중복 구간 텍스트 매칭
```
청크 1의 끝: "...회의를 마치도록 하겠습니다."
청크 2의 시작: "회의를 마치도록 하겠습니다. 감사합니다."

→ "회의를 마치도록 하겠습니다." 매칭 발견 (유사도: 95%)
→ 청크 2에서 중복 부분 제거
```

### 4단계: 병합 및 시간 오프셋 조정
```
청크 2의 세그먼트 시간에 +1770초 (29분 35초) 오프셋 추가
최종 결과: 연속적인 세그먼트 리스트
```

## 장점

1. **안정성**: 긴 파일에서 JSON 파싱 에러 방지
2. **정확성**: 중복 구간을 통한 정확한 텍스트 병합
3. **유연성**: 청크 크기와 중복 시간 조정 가능
4. **자동 Fallback**: 짧은 파일은 자동으로 일반 처리

## 제한사항

1. **처리 시간**: 청크 처리로 인해 전체 처리 시간이 약간 증가할 수 있음
2. **임시 파일**: 청크 파일을 임시로 저장하므로 디스크 공간 필요
3. **병합 정확도**: 중복 구간에서 명확한 텍스트가 없으면 병합이 부정확할 수 있음

## 예제 출력

```
🔪 오디오 분할 시작: mp3/meeting_60min.mp3
📏 총 오디오 길이: 3600.00초 (60.00분)
📦 청크 1 생성: 0.00s ~ 1800.00s (길이: 30.00분)
📦 청크 2 생성: 1775.00s ~ 3575.00s (길이: 30.00분)
📦 청크 3 생성: 3550.00s ~ 3600.00s (길이: 0.83분)
✅ 오디오 분할 완료: 3개 청크

🎯 청크 1/3 처리: 0.00s ~ 1800.00s
✅ Gemini STT 완료: 120개 세그먼트

🎯 청크 2/3 처리: 1775.00s ~ 3575.00s
✅ Gemini STT 완료: 115개 세그먼트

🎯 청크 3/3 처리: 3550.00s ~ 3600.00s
✅ Gemini STT 완료: 8개 세그먼트

🔗 세그먼트 병합 시작: 3개 청크
✅ 청크 0: 120개 세그먼트 추가
🔗 중복 구간 발견: 12단어 매칭 (유사도: 92.50%)
✅ 청크 1: 108개 세그먼트 추가 (처음 7개 중복 제거)
🔗 중복 구간 발견: 5단어 매칭 (유사도: 85.00%)
✅ 청크 2: 6개 세그먼트 추가 (처음 2개 중복 제거)
✅ 병합 완료: 총 234개 세그먼트

✅ 청크 처리 완료: 234개 세그먼트, 언어: ko (325.50초)
```

## 기존 코드와의 통합

기존 코드에서 `recognize_with_gemini`를 사용하는 곳을 `recognize_with_gemini_chunked`로 교체하면 됩니다.

### 이전 코드
```python
from modules.stt import recognize_with_gemini

segments, time, lang = recognize_with_gemini(audio_path)
```

### 변경 후
```python
from modules.stt import recognize_with_gemini_chunked

# 긴 파일에 대해 자동으로 청크 처리
segments, time, lang = recognize_with_gemini_chunked(audio_path)
```

**주의**: `recognize_with_gemini_chunked`는 짧은 파일(30분 이하)에 대해서는 자동으로 일반 처리 방식을 사용하므로, 모든 파일에 대해 사용해도 안전합니다.

## 문제 해결

### JSON 파싱 에러가 여전히 발생하는 경우
- `chunk_duration_minutes`를 줄여보세요 (예: 20분)
- `overlap_seconds`를 늘려보세요 (예: 30초)

### 병합이 부정확한 경우
- `overlap_seconds`를 늘려보세요
- 중복 구간에 명확한 발화가 있는지 확인하세요

### 처리 시간이 너무 긴 경우
- `chunk_duration_minutes`를 늘려보세요 (단, JSON 에러 위험 증가)
- 청크 수를 줄이면 처리 시간이 단축됩니다

## 관련 파일

- `modules/stt.py`: 구현 코드
  - `split_audio_with_overlap()`: 오디오 분할
  - `find_best_overlap_match()`: 중복 텍스트 찾기
  - `merge_segment_lists()`: 세그먼트 병합
  - `recognize_with_gemini_chunked()`: 메인 함수
- `test_chunked_stt.py`: 테스트 스크립트
- `CHUNKED_STT_GUIDE.md`: 이 가이드 문서

## 추가 개선 사항 (향후)

1. **병렬 처리**: 여러 청크를 동시에 처리하여 시간 단축
2. **적응형 청크 크기**: 오디오 특성에 따라 자동으로 청크 크기 조정
3. **더 정교한 병합**: NLP 기반 의미론적 유사도 매칭
4. **진행 상황 저장**: 중간 결과 저장으로 재시작 가능

## 라이센스 및 기여

이 구현은 smartNote 프로젝트의 일부입니다.
